<!DOCTYPE html>
<html lang="zh-Hant">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>LINE 貼圖 4×3 工廠（Web Worker 去背版）</title>

  <!-- Tailwind -->
  <script src="https://cdn.tailwindcss.com"></script>

  <style>
    body {
      background: #020617;
      color: #f9fafb;
    }
    canvas {
      image-rendering: pixelated;
    }
  </style>
</head>

<body class="min-h-screen">
  <div class="max-w-5xl mx-auto p-4 md:p-8">
    <header class="mb-6">
      <h1 class="text-2xl md:text-3xl font-bold mb-2">
        LINE 貼圖 4×3 工廠（Web Worker 去背強化）
      </h1>
      <p class="text-slate-400 text-sm">
        上傳一張 <span class="font-mono">4×3</span> 網格的大圖（例如 1480×960），系統會自動切成 12 張，
        再丟到 Web Worker 去背，加速又不失真。
      </p>
    </header>

    <!-- 上傳 + 設定 -->
    <section class="grid md:grid-cols-2 gap-6 mb-6">
      <!-- 上傳區 -->
      <div class="bg-slate-800/80 rounded-xl p-4 shadow">
        <h2 class="text-lg font-semibold mb-3">1️⃣ 上傳貼圖大圖</h2>
        <input id="fileInput" type="file" accept="image/*"
               class="block w-full text-sm text-slate-100
                      file:mr-4 file:py-2 file:px-4
                      file:rounded-md file:border-0
                      file:text-sm file:font-semibold
                      file:bg-emerald-500 file:text-white
                      hover:file:bg-emerald-600" />
        <p class="text-xs text-slate-400 mt-2">
          建議：背景是<strong>純綠 #00ff00</strong> 的 4×3 角色貼圖集（例如 LINE 規格 1480×960）。
        </p>

        <div id="previewWrapper" class="mt-4 hidden">
          <p class="text-xs text-slate-300 mb-1">原始預覽：</p>
          <div class="border border-slate-600 rounded-lg overflow-hidden bg-slate-900/60">
            <img id="sheetPreview" class="max-h-64 w-full object-contain" />
          </div>
        </div>
      </div>

      <!-- 設定區 -->
      <div class="bg-slate-800/80 rounded-xl p-4 shadow space-y-3">
        <h2 class="text-lg font-semibold mb-3">2️⃣ 去背設定（送進 Worker）</h2>

        <div class="space-y-1">
          <label class="text-sm">背景顏色</label>
          <select id="bgColor" class="w-full text-sm text-black rounded-md px-2 py-1">
            <option value="#00ff00">綠幕 #00FF00（建議）</option>
            <option value="#000000">黑色 #000000</option>
            <option value="#ffffff">白色 #FFFFFF</option>
          </select>
        </div>

        <div class="space-y-1">
          <label class="text-sm flex justify-between">
            <span>容許度（Tolerance）</span>
            <span class="text-emerald-300 text-xs">愈大愈寬鬆：<span id="tolLabel">40</span></span>
          </label>
          <input id="tolerance" type="range" min="1" max="100" value="40" class="w-full" />
        </div>

        <div class="space-y-1">
          <label class="text-sm flex justify-between">
            <span>邊緣內縮（Erosion px）</span>
            <span class="text-emerald-300 text-xs"><span id="erodeLabel">1</span> px</span>
          </label>
          <input id="erode" type="range" min="0" max="5" value="1" class="w-full" />
        </div>

        <div class="space-y-1">
          <label class="text-sm">去背模式</label>
          <select id="mode" class="w-full text-sm text-black rounded-md px-2 py-1">
            <option value="global">全域（較快）</option>
            <option value="flood">Flood Fill（保護角色，較慢）</option>
          </select>
        </div>

        <button id="processBtn"
                class="mt-3 w-full py-2 rounded-md bg-emerald-500 hover:bg-emerald-600
                       font-semibold text-sm flex items-center justify-center gap-2">
          <span id="processBtnText">3️⃣ 開始切割 + 去背</span>
          <span id="processBtnSpinner" class="hidden animate-spin border-2 border-t-transparent border-white rounded-full w-4 h-4"></span>
        </button>

        <p id="statusText" class="text-xs text-slate-400 mt-1"></p>
      </div>
    </section>

    <!-- 結果 -->
    <section class="bg-slate-800/80 rounded-xl p-4 shadow mb-8">
      <div class="flex items-center justify-between mb-3">
        <h2 class="text-lg font-semibold">4️⃣ 結果預覽（12 張）</h2>
        <button id="downloadAllBtn"
                class="px-3 py-1.5 text-xs rounded bg-sky-500 hover:bg-sky-600 font-semibold disabled:opacity-40"
                disabled>
          下載全部 PNG（ZIP）
        </button>
      </div>
      <div id="resultArea"
           class="grid grid-cols-2 md:grid-cols-4 lg:grid-cols-6 gap-4 text-xs"></div>
    </section>

    <footer class="text-center text-xs text-slate-500 mb-4">
      © 2025 LINE Sticker Factory Demo（Web Worker 去背版本）
    </footer>
  </div>

  <!-- 主邏輯：純原生 JS，無 React 依賴 -->
  <script>
    const fileInput = document.getElementById('fileInput');
    const previewWrapper = document.getElementById('previewWrapper');
    const sheetPreview = document.getElementById('sheetPreview');
    const processBtn = document.getElementById('processBtn');
    const processBtnText = document.getElementById('processBtnText');
    const processBtnSpinner = document.getElementById('processBtnSpinner');
    const statusText = document.getElementById('statusText');
    const resultArea = document.getElementById('resultArea');
    const downloadAllBtn = document.getElementById('downloadAllBtn');

    const bgColorSel = document.getElementById('bgColor');
    const tolRange = document.getElementById('tolerance');
    const erodeRange = document.getElementById('erode');
    const tolLabel = document.getElementById('tolLabel');
    const erodeLabel = document.getElementById('erodeLabel');
    const modeSel = document.getElementById('mode');

    tolRange.addEventListener('input', () => {
      tolLabel.textContent = tolRange.value;
    });
    erodeRange.addEventListener('input', () => {
      erodeLabel.textContent = erodeRange.value;
    });

    let uploadedImage = null;
    let worker = null;

    function ensureWorker() {
      if (!worker) {
        worker = new Worker('removeBgWorker.js');
      }
      return worker;
    }

    fileInput.addEventListener('change', (e) => {
      const file = e.target.files[0];
      if (!file) return;
      const reader = new FileReader();
      reader.onload = (ev) => {
        const img = new Image();
        img.onload = () => {
          uploadedImage = img;
          sheetPreview.src = img.src;
          previewWrapper.classList.remove('hidden');
          statusText.textContent = '圖片載入完成，請按「開始切割 + 去背」。';
          resultArea.innerHTML = '';
          downloadAllBtn.disabled = true;
        };
        img.src = ev.target.result;
      };
      reader.readAsDataURL(file);
    });

    async function processImage() {
      if (!uploadedImage) {
        alert('請先上傳一張 4×3 的貼圖大圖！');
        return;
      }

      processBtn.disabled = true;
      processBtnSpinner.classList.remove('hidden');
      statusText.textContent = '正在切割與去背中…';

      const cols = 4;
      const rows = 3;

      const sheetCanvas = document.createElement('canvas');
      sheetCanvas.width = uploadedImage.width;
      sheetCanvas.height = uploadedImage.height;
      const sheetCtx = sheetCanvas.getContext('2d');
      sheetCtx.drawImage(uploadedImage, 0, 0);

      const pieceW = sheetCanvas.width / cols;
      const pieceH = sheetCanvas.height / rows;

      const pieces = [];
  </script>
  <script>
      // 承上段，接續 processImage 內部與後續程式碼

      // ...前面已宣告 const pieces = [];

      for (let r = 0; r < rows; r++) {
        for (let c = 0; c < cols; c++) {
          const pieceCanvas = document.createElement('canvas');
          pieceCanvas.width = pieceW;
          pieceCanvas.height = pieceH;
          const pCtx = pieceCanvas.getContext('2d');
          pCtx.drawImage(
            sheetCanvas,
            c * pieceW, r * pieceH, pieceW, pieceH,
            0, 0, pieceW, pieceH
          );
          pieces.push(pieceCanvas);
        }
      }

      const processedCanvases = [];
      const w = ensureWorker();

      // 將 worker 回傳結果封裝成 Promise
      function runWorkerOnCanvas(canvas) {
        return new Promise((resolve) => {
          const ctx = canvas.getContext('2d');
          const imgData = ctx.getImageData(0, 0, canvas.width, canvas.height);

          w.onmessage = (ev) => {
            const processed = ev.data;
            ctx.putImageData(processed, 0, 0);
            resolve(canvas);
          };

          w.postMessage({
            imageData: imgData,
            width: canvas.width,
            height: canvas.height,
            targetHex: bgColorSel.value,
            tolerancePercent: Number(tolRange.value),
            erodeStrength: Number(erodeRange.value),
            removalMode: modeSel.value
          });
        });
      }

      resultArea.innerHTML = '';

      // 逐張處理（也可以改成 Promise.all 但 UI 不會有差很多）
      for (let i = 0; i < pieces.length; i++) {
        statusText.textContent = `正在處理第 ${i+1} / ${pieces.length} 張…`;
        /* eslint-disable no-await-in-loop */
        const processedCanvas = await runWorkerOnCanvas(pieces[i]);
        processedCanvases.push(processedCanvas);

        const dataUrl = processedCanvas.toDataURL('image/png');

        const wrapper = document.createElement('div');
        wrapper.className = 'space-y-1';

        const imgEl = document.createElement('img');
        imgEl.src = dataUrl;
        imgEl.className = 'w-full aspect-[370/320] object-contain bg-slate-900 rounded border border-slate-600';

        const label = document.createElement('div');
        label.className = 'text-center text-[10px] text-slate-300';
        const num = String(i + 1).padStart(2, '0');
        label.textContent = `#${num}.png`;

        const dlBtn = document.createElement('button');
        dlBtn.textContent = '下載';
        dlBtn.className = 'mt-1 w-full text-[10px] px-2 py-1 rounded bg-sky-500 hover:bg-sky-600';
        dlBtn.addEventListener('click', () => {
          const a = document.createElement('a');
          a.href = dataUrl;
          a.download = `${num}.png`;
          a.click();
        });

        wrapper.appendChild(imgEl);
        wrapper.appendChild(label);
        wrapper.appendChild(dlBtn);

        resultArea.appendChild(wrapper);
      }

      statusText.textContent = '全部完成！你可以分別下載，或按右上角 ZIP 一次打包。';
      downloadAllBtn.disabled = false;

      // 把處理好的 Canvas 暫存到按鈕上，讓 ZIP 打包時用
      downloadAllBtn._canvases = processedCanvases;

      processBtn.disabled = false;
      processBtnSpinner.classList.add('hidden');
    }

    processBtn.addEventListener('click', () => {
      processImage().catch((err) => {
        console.error(err);
        alert('發生錯誤，請開 F12 看 Console。');
        processBtn.disabled = false;
        processBtnSpinner.classList.add('hidden');
        statusText.textContent = '處理失敗。';
      });
    });

    // 下載全部 ZIP（使用 JSZip CDN）
    // 為了避免多載一個 CDN，如果你不需要 ZIP，可以把這段移除
  </script>

  <!-- JSZip CDN（用於 ZIP 打包） -->
  <script src="https://cdnjs.cloudflare.com/ajax/libs/jszip/3.10.1/jszip.min.js"></script>
  <script>
    downloadAllBtn.addEventListener('click', async () => {
      const canvases = downloadAllBtn._canvases;
      if (!canvases || !canvases.length) {
        alert('目前沒有可打包的圖片。');
        return;
      }

      downloadAllBtn.disabled = true;
      downloadAllBtn.textContent = '打包中…';

      const zip = new JSZip();
      canvases.forEach((cv, idx) => {
        const num = String(idx + 1).padStart(2, '0');
        const dataUrl = cv.toDataURL('image/png');
        const base64 = dataUrl.split(',')[1];
        zip.file(`${num}.png`, base64, { base64: true });
      });

      const blob = await zip.generateAsync({ type: 'blob' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = 'stickers.zip';
      a.click();
      URL.revokeObjectURL(url);

      downloadAllBtn.disabled = false;
      downloadAllBtn.textContent = '下載全部 PNG（ZIP）';
    });
  </script>

</body>
</html>
